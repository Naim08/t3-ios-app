import { renderHook, waitFor, act } from '@testing-library/react-native';
import { useCredits, spendTokens } from '../useCredits';

// Mock supabase with proper typing
const mockInvoke = jest.fn();

jest.mock('../../lib/supabase', () => ({
  supabase: {
    functions: {
      invoke: mockInvoke,
    },
  },
}));

describe('useCredits', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should fetch credits on mount', async () => {
    mockInvoke.mockResolvedValueOnce({
      data: { remaining: 1500 },
      error: null,
    });

    const { result } = renderHook(() => useCredits());

    expect(result.current.loading).toBe(true);

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.remaining).toBe(1500);
    expect(result.current.error).toBe(null);
    expect(mockInvoke).toHaveBeenCalledWith('get_credits');
  });

  it('should handle fetch error', async () => {
    mockInvoke.mockResolvedValueOnce({
      data: null,
      error: new Error('Network error'),
    });

    const { result } = renderHook(() => useCredits());

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.remaining).toBe(0);
    expect(result.current.error).toBe('Network error');
  });

  it('should refetch credits when refetch is called', async () => {
    mockInvoke
      .mockResolvedValueOnce({
        data: { remaining: 1500 },
        error: null,
      })
      .mockResolvedValueOnce({
        data: { remaining: 1200 },
        error: null,
      });

    const { result } = renderHook(() => useCredits());

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.remaining).toBe(1500);

    await act(async () => {
      await result.current.refetch();
    });

    expect(result.current.remaining).toBe(1200);
    expect(mockInvoke).toHaveBeenCalledTimes(2);
  });
});

describe('spendTokens', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should spend tokens successfully', async () => {
    mockInvoke.mockResolvedValueOnce({
      data: { remaining: 1200 },
      error: null,
    });

    const result = await spendTokens(300);

    expect(result.remaining).toBe(1200);
    expect(mockInvoke).toHaveBeenCalledWith('spend_tokens', {
      body: { amount: 300 }
    });
  });

  it('should throw error for insufficient credits', async () => {
    mockInvoke.mockResolvedValueOnce({
      data: null,
      error: { message: 'insufficient_credits' },
    });

    await expect(spendTokens(1000)).rejects.toThrow('Insufficient credits');
  });

  it('should throw error for other failures', async () => {
    mockInvoke.mockResolvedValueOnce({
      data: null,
      error: { message: 'Database error' },
    });

    await expect(spendTokens(100)).rejects.toThrow();
  });
});
